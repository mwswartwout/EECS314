#actual start of the main program
	.globl main
main:				#main has to be a global label

Start:
	jal encryptOrDecrypt
	#jal getFileName	#Not working right now
	jal getModulus
	jal getExponent
	jal readFile
	#jal testChange
	jal testPrint
			
	#beq	$s0, $0, Encrypt
	#j Decrypt

encryptOrDecrypt:
	la	$a0, promptED	#prompt for encrypt or decrypt
	li	$v0,4
	syscall
	
	li	$v0, 5
	syscall
	move $s0, $v0	#save user input to register (0:e, 1:d)
	
	jr $ra

getFileName:
	# get file name from user
	li	$v0, 4		# prompt user for file name to read
	la	$a0, promptFN
	syscall
	
	li	$v0, 8		# retrieve user input
	la	$a0, fname	# location to store string
	li	$a1, 100	# max number of characters
	syscall

	jr	$ra		# return to main method
		
getModulus:
	la $a0, promptM
	li $v0, 4
	syscall

	li $v0, 5
	syscall
	move $s1, $v0	#product key in $s6 ($s6 = n)
	
	jr $ra
	
getExponent:
	la $a0, promptE
	li $v0, 4
	syscall

	li $v0, 5
	syscall
	move $s2, $v0	#encryption key in $s7 ($s7 = e)

	jr $ra	

readFile:	
	li   	$v0, 13       	# system call for open file
 	la   	$a0, fname   	# output file name
  	li   	$a1, 0       	# Open for reading (flags are 0: read, 1: write)
  	li   	$a2, 0       	# mode is ignored
  	syscall            	# open a file (file descriptor returned in $v0)

  	move 	$s6, $v0     	# save the file descriptor 
  
 	# read from file just opened
 	li   	$v0, 14      	# system call for read from file
  	move 	$a0, $s6     	# file descriptor 
  	la   	$a1, input  	# address to store text from file
  	li   	$a2, 10000      # hardcoded buffer length
  	syscall           	# read file
  
 	# Close the file 
  	li   	$v0, 16      	# system call for close file
  	move 	$a0, $s6     	# file descriptor to close
  	syscall          	# close file

	#jal	Test_Print	#NEED TO SAVE ADDRESS TO DIFFERENT REGISTER!!!
	#jal	Test_Change	#Test functions commented out

	jr $ra

testPrint:
	la	$a0, input
	li	$v0, 4
	syscall
	jr	$ra

testChange:
	li	$v0, 4
	la	$t0, input
	
printLoop:
	lb	$t2, ($t0)
	beqz	$t2, JReturn
	jal	encrChar
	sb	$t2, ($t0)
	addi	$t0, $t0, 1
	j	printLoop

JReturn:
	la	$a0, input
	syscall
	
	jr	$ra
	
encrChar:
	add $t0, $s7, $0	#number of times to execute mult loop
	li $t1, 1		#$t0 will contain value^key (m^e)
 mPowE:	mult $t1, $s1		#multiply by $s1 (char's ascii value)
	mflo $t1		#move result of multiply to $t1
	addi $t0, $t0, -1	#decrement $t0
	bne $t0, $0, mPowE	#branch to top of loop if not fininshed 

 modN:	slt $t0, $t1, $s6	#if working value < n, t0 = 1
	bne $t0, $0, exitModN		#exit loop (loop performs mod n)
	sub $t1, $t1, $s6	#subtract n from the working value
	j modN
 exitModN:
	jr $ra

#Decrypt:
#	la $a0, promptDec #Prints prompt to enter public modulus
#	li $v0, 4
#	syscall	
#
#	li $v0, 5
#	syscall	
#	move $s8, $v0 #stores the public modulus in s8
#	
#	li $a0, promtDec2 #Prints prompt to enter the private exponent
#	li $v0, 4
#	syscall
#	
#	li $v0, 5
#	syscall
#	move $s9, $v0 #stores the private exponent is s9
#	
#	
	
	
#	j Exit

Exit:	
	la $a0, promptExit
	li $v0, 4
	syscall

	li $v0, 5
	syscall
	add $s0, $v0, $0

	beq $v0, $0, Start
	
.data

promptED: .asciiz "What do you want to do with the file?\n0: Encryption\n1:Decryption\n... "
promptE: .asciiz "Enter the encryption key.\n"
promptM: .asciiz "Enter the modulus.\n"
promptDec: .asciiz "Enter the public modulus.\n"
promptDec2: .asciiz "Enter the public exponent. \n"
promptExit: .asciiz "Would you like to exit?\n0: Decrypt/Encrypt another file.\n1: Exit.\n..."

promptFN:	.asciiz	"Enter the file name you wish to input: "
fname:	.asciiz	"C:\\Users\\Public\\rsa.txt"	# file name to read
input:	.space	100	# location for input from file

        .text
  
  	# Prompt for a file name, then read from file and store contents in 'input'
